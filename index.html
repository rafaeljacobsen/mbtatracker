<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTA Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            width: 180px;
            max-height: none;
            overflow: hidden;
        }
        
        .info-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
        }
        
        .coordinates {
            font-family: monospace;
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .filter-controls {
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 0 10px 0;
        }
        
        .filter-controls h4 {
            margin: 0;
            font-size: 14px;
            color: #555;
        }
        
        .lines-toggle {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .lines-toggle:hover {
            background: #0056b3;
        }
        
        .lines-toggle.collapsed {
            transform: rotate(180deg);
        }
        
        .category-filters {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .category-filters.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }
        
        .filter-checkbox {
            margin: 4px 0;
            font-size: 13px;
            display: flex;
            align-items: center;
            height: 20px;
        }
        
        .filter-checkbox input {
            margin-right: 8px;
            margin: 0;
        }
        
        .filter-checkbox label {
            margin: 0;
            line-height: 1;
        }
        
        .stats {
            background: #e9ecef;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 200px;
            overflow: hidden;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px 6px 10px;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }
        
        .panel-header h3, .panel-header h4 {
            margin: 0;
            color: #333;
        }
        
        .panel-toggle {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            width: 30px;
            height: 60px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 4px 0 10px rgba(0,0,0,0.4);
        }
        
        .panel-toggle:hover {
            background: #0056b3;
            width: 25px;
        }
        
        .panel-content {
            padding: 10px;
            max-height: none;
            overflow-y: visible;
        }
        
        .panel-hidden {
            transform: translateX(-100%);
        }
        
        .panel-hidden .panel-toggle {
            right: -20px;
            background: #666;
        }
        
        .info-panel {
            transition: transform 0.3s ease;
        }
        
        .legend {
            transition: transform 0.3s ease;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #333;
        }
        
        .search-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            z-index: 1000;
            width: 250px;
        }
        
        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .search-result {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 13px;
        }
        
        .search-result:hover {
            background: #f5f5f5;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel" id="info-panel">
        <button class="panel-toggle" onclick="togglePanel('info-panel')">◀</button>

        
        <div class="panel-content">
            <div class="filter-controls">
                <div class="filter-header">
                    <h4>Show/Hide Lines:</h4>
                    <button class="lines-toggle" onclick="toggleLinesSection()" title="Hide/Show Lines Section">−</button>
                </div>
                
                <!-- Subway, Commuter Rail, and Seasonal Rail toggles -->
                <div class="category-filters" id="lines-section">
                    <div class="filter-checkbox">
                        <input type="checkbox" id="show-subway" checked>
                        <label for="show-subway">All Subway Lines</label>
                    </div>
                    <div class="filter-checkbox">
                        <input type="checkbox" id="show-commuter" checked>
                        <label for="show-commuter">All Commuter Rail</label>
                    </div>
                    <div class="filter-checkbox">
                        <input type="checkbox" id="show-seasonal">
                        <label for="show-seasonal">Seasonal Rail</label>
                    </div>
                </div>
            </div>
        </div>
    </div>
    

    


    <!-- Include the MBTA stops data -->
    <script src="mbta-stops-accurate.js"></script>

    <script>
        // Global variables - declare these first
        const trainMarkers = new Map();
        const amtrakMarkers = new Map();
        let trackingInterval;
        let amtrakTrackingInterval;
        let lastUpdateTime = 0;
        let lastAmtrakUpdateTime = 0;
        
        // Check if data is ready before proceeding
        if (typeof mbtaStopsData === 'undefined' || !mbtaStopsData) {
            document.getElementById('map').innerHTML = '<div style="text-align: center; padding: 50px; font-size: 18px; color: #666;">Loading MBTA data...</div>';
            // Don't run any more code
            throw new Error('MBTA data not loaded');
        }
        
        // Initialize the map centered on Boston
        const map = L.map('map').setView([42.3601, -71.0589], 11);
        
        // Add OpenStreetMap tiles
        const osmTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        });
        
        osmTiles.addTo(map);
        
        // Create layer groups for each transit line
        const layers = {};
        
        // Initialize layers for all lines
        if (mbtaStopsData && typeof mbtaStopsData === 'object') {
            try {
                Object.keys(mbtaStopsData).forEach(lineName => {
                    layers[lineName] = L.layerGroup();
                    map.addLayer(layers[lineName]);
                });
            } catch (e) {
                // Silently handle any errors
            }
        }
        
        // Generate filter checkboxes dynamically
        const filterContainer = document.getElementById('filter-checkboxes');
        
        // Define subway, commuter rail, and seasonal rail lines
        const subwayLines = ['Red Line', 'Orange Line', 'Blue Line', 'Green Line B', 'Green Line C', 'Green Line D', 'Green Line E', 'Mattapan Trolley'];
        const commuterLines = ['Fairmount Line', 'Fall River/New Bedford Line', 'Fitchburg Line', 'Framingham/Worcester Line', 'Franklin/Foxboro Line', 'Greenbush Line', 'Haverhill Line', 'Kingston Line', 'Lowell Line', 'Needham Line', 'Newburyport/Rockport Line', 'Providence/Stoughton Line', 'Foxboro Event Service'];
        const seasonalLines = ['CapeFLYER'];
        

        
        // Add event listeners for category filters
        document.getElementById('show-subway').addEventListener('change', function() {
            const isChecked = this.checked;
            subwayLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            // Hide/show train markers for subway lines
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (subwayLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            updateStats();
        });
        
        document.getElementById('show-commuter').addEventListener('change', function() {
            const isChecked = this.checked;
            commuterLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            // Hide/show train markers for commuter rail lines
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (commuterLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            updateStats();
        });
        
        document.getElementById('show-seasonal').addEventListener('change', function() {
            const isChecked = this.checked;
            seasonalLines.forEach(lineName => {
                if (mbtaStopsData[lineName] && layers[lineName]) {
                    if (isChecked) {
                        map.addLayer(layers[lineName]);
                    } else {
                        map.removeLayer(layers[lineName]);
                    }
                }
            });
            // Hide/show train markers for seasonal rail lines
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.routeName) {
                    if (seasonalLines.includes(marker.routeName)) {
                        if (isChecked) {
                            marker.addTo(map);
                        } else {
                            marker.remove();
                        }
                    }
                }
            });
            updateStats();
        });
        
        // Color scheme for different lines
        const lineColors = {
            'Red Line': '#DA291C',
            'Orange Line': '#ED8B00',
            'Blue Line': '#003DA5',
            'Green Line B': '#00843D',
            'Green Line C': '#00843D',
            'Green Line D': '#00843D',
            'Green Line E': '#00843D',
            'Mattapan Trolley': '#DA291C',
            'Fairmount Line': '#800080',
            'Fall River/New Bedford Line': '#800080',
            'Fitchburg Line': '#800080',
            'Foxboro Event Service': '#800080',
            'Framingham/Worcester Line': '#800080',
            'Franklin/Foxboro Line': '#800080',
            'Greenbush Line': '#800080',
            'Haverhill Line': '#800080',
            'Kingston Line': '#800080',
            'Lowell Line': '#800080',
            'Needham Line': '#800080',
            'Newburyport/Rockport Line': '#800080',
            'Providence/Stoughton Line': '#800080'
        };
        

        
                    // Create markers and tracks for all routes
            const markers = [];
            const stopMarkers = new Map(); // Track markers by stopId for multi-line stops
            
            if (typeof mbtaStopsData !== 'undefined' && typeof routeShapes !== 'undefined') {
                
                let totalTracksDrawn = 0;
                let totalStopsDrawn = 0;
                
                // Batch processing for better performance
                const processRoute = (lineName, stops, color) => {
                    const routeMarkers = [];
                    const routeTracks = [];
                    
                    // Process track shapes
                    if (routeShapes[lineName] && routeShapes[lineName].length > 0) {
                        routeShapes[lineName].forEach((shape, shapeIndex) => {
                            if (shape.coords && shape.coords.length > 1) {
                                // Optimized duplicate coordinate removal
                                const cleanCoords = [];
                                let prevLat = null, prevLon = null;
                                
                                for (let i = 0; i < shape.coords.length; i++) {
                                    const coord = shape.coords[i];
                                    if (prevLat !== coord[0] || prevLon !== coord[1]) {
                                        cleanCoords.push(coord);
                                        prevLat = coord[0];
                                        prevLon = coord[1];
                                    }
                                }
                                
                                if (cleanCoords.length > 1) {
                                    const trackLine = L.polyline(cleanCoords, {
                                        color: color,
                                        weight: 3,
                                        opacity: 0.7
                                    });
                                    
                                    trackLine.bindPopup(`<b>${lineName}</b> Shape ${shapeIndex + 1} Track`);
                                    routeTracks.push(trackLine);
                                    totalTracksDrawn++;
                                }
                            }
                        });
                    }
                    
                    // Process stop markers
                    stops.forEach(stop => {
                        const stopRoutes = stopToRoutes[stop.stopId] || [];
                        const isMultiLine = stopRoutes.length > 1;
                        
                        if (isMultiLine && stopMarkers.has(stop.stopId)) {
                            const existingMarker = stopMarkers.get(stop.stopId);
                            existingMarker.options.colors = existingMarker.options.colors || [];
                            existingMarker.options.colors.push(color);
                            
                            const allLines = stopRoutes.join(', ');
                            existingMarker.bindPopup(`
                                <b>${stop.name}</b><br>
                                Type: ${stop.type}<br>
                                Lines: ${allLines}<br>
                                Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}
                            `);
                        } else {
                            const marker = L.circleMarker(stop.coords, {
                                radius: isMultiLine ? 8 : 6,
                                fillColor: color,
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8,
                                colors: isMultiLine ? [color] : undefined
                            });
                            
                            const popupText = isMultiLine ? 
                                `<b>${stop.name}</b><br>Type: ${stop.type}<br>Lines: ${stopRoutes.join(', ')}<br>Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}` :
                                `<b>${stop.name}</b><br>Type: ${stop.type}<br>Line: ${lineName}<br>Coordinates: ${stop.coords[0].toFixed(6)}, ${stop.coords[1].toFixed(6)}`;
                            
                            marker.bindPopup(popupText);
                            routeMarkers.push(marker);
                            totalStopsDrawn++;
                            
                            if (isMultiLine) {
                                stopMarkers.set(stop.stopId, marker);
                            }
                        }
                    });
                    
                    return { markers: routeMarkers, tracks: routeTracks };
                };
                
                // Process routes in chunks to prevent UI freezing
                const routes = Object.entries(mbtaStopsData);
                const chunkSize = 5; // Process 5 routes at a time
                
                const processChunk = (startIndex) => {
                    const endIndex = Math.min(startIndex + chunkSize, routes.length);
                    const chunk = routes.slice(startIndex, endIndex);
                    
                    chunk.forEach(([lineName, stops]) => {
                        const color = lineColors[lineName] || '#666';
                        const result = processRoute(lineName, stops, color);
                        
                        // Batch add markers and tracks to layers
                        result.markers.forEach(marker => {
                            markers.push(marker);
                            layers[lineName].addLayer(marker);
                        });
                        
                        result.tracks.forEach(track => {
                            markers.push(track);
                            layers[lineName].addLayer(track);
                        });
                    });
                    
                    // Process next chunk if there are more routes
                    if (endIndex < routes.length) {
                        setTimeout(() => processChunk(endIndex), 10); // 10ms delay between chunks
                    } else {
        
                    }
                };
                
                // Start processing
                processChunk(0);
                
            } else {
                console.error('Cannot create markers: mbtaStopsData or routeShapes is undefined');
            }
        
        // Update stats display (no-op since stats were removed)
        function updateStats() {
            // Stats display was removed - function kept for compatibility
        }
        

        

        
        // Filter controls are now generated dynamically above
        

        
        // Panel toggle functionality
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const toggle = panel.querySelector('.panel-toggle');
            
            if (panel.classList.contains('panel-hidden')) {
                // Show panel
                panel.classList.remove('panel-hidden');
                toggle.textContent = '◀';
            } else {
                // Hide panel
                panel.classList.add('panel-hidden');
                toggle.textContent = '▶';
            }
        }
        
        // Lines section toggle functionality
        function toggleLinesSection() {
            const linesSection = document.getElementById('lines-section');
            const toggle = document.querySelector('.lines-toggle');
            
            if (linesSection.classList.contains('collapsed')) {
                // Show lines section
                linesSection.classList.remove('collapsed');
                toggle.textContent = '−';
                toggle.classList.remove('collapsed');
            } else {
                // Hide lines section
                linesSection.classList.add('collapsed');
                toggle.textContent = '+';
                toggle.classList.add('collapsed');
            }
        }
        
        // Initialize stats
        updateStats();
        
        // Add scale control
        const scaleControl = L.control.scale({
            position: 'bottomleft'
        }).addTo(map);
        

        

        
        // Live MBTA Train Tracking
        

        
        // Function to fetch live train positions
        async function fetchLiveTrains() {
            try {
                const now = Date.now();
                if (now - lastUpdateTime < 15000) { // Rate limit: 15 seconds
                    return;
                }
                
                const response = await fetch('https://api-v3.mbta.com/vehicles?filter[route_type]=0,1,2&include=route');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                lastUpdateTime = now;
                
                if (data.data && data.data.length > 0) {
                    updateTrainMarkers(data.data);
                }
                
            } catch (error) {
                console.error('Error fetching MBTA trains:', error);
            }
        }
        

        
        // Function to update train markers on the map
        function updateTrainMarkers(trains) {
            // Clear old train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            trainMarkers.clear();
            
            // Create new train markers
                            trains.forEach(train => {
                    if (train.attributes && train.attributes.latitude && train.attributes.longitude) {
                        const trainId = train.id;
                        const lat = train.attributes.latitude;
                        const lng = train.attributes.longitude;
                        const heading = train.attributes.heading || 0;
                        const speed = train.attributes.speed;
                        const currentStatus = train.attributes.current_status;
                        const routeId = train.relationships?.route?.data?.id;
                        

                        

                    
                    // Get route name and color with better matching
                    let routeName = 'Unknown Route';
                    let color = '#666';
                    
                    if (routeId && mbtaStopsData) {

                        
                        // Better route matching logic
                        if (mbtaStopsData) {
                            Object.keys(mbtaStopsData).forEach(name => {
                                // Check for exact matches first
                                if (name === routeId || 
                                    name.replace(/\s+/g, '') === routeId ||
                                    name.replace(/\s+/g, '') === routeId.replace(/\s+/g, '') ||
                                    routeId.includes(name.replace(/\s+/g, '')) ||
                                    name.includes(routeId.replace(/\s+/g, ''))) {
                                    routeName = name;
                                    color = lineColors[name] || '#666';
                                }
                            });
                            
                            // If no match found, try partial matching for commuter rail
                            if (routeName === 'Unknown Route' && routeId.startsWith('CR-')) {
                                Object.keys(mbtaStopsData).forEach(name => {
                                    if (name.includes('Line') && routeId.includes(name.split(' ')[0])) {
                                        routeName = name;
                                        color = lineColors[name] || '#800080'; // Default purple for commuter rail
                                    }
                                });
                            }
                            
                            // If still no match, try to identify Green Line routes specifically
                            if (routeName === 'Unknown Route' && (routeId.includes('Green') || routeId.includes('GL'))) {
                                // Try to match specific Green Line branch
                                if (routeId.includes('Green-B') || routeId.includes('GL-B')) {
                                    routeName = 'Green Line B';
                                } else if (routeId.includes('Green-C') || routeId.includes('GL-C')) {
                                    routeName = 'Green Line C';
                                } else if (routeId.includes('Green-D') || routeId.includes('GL-D')) {
                                    routeName = 'Green Line D';
                                } else if (routeId.includes('Green-E') || routeId.includes('GL-E')) {
                                    routeName = 'Green Line E';
                                } else {
                                    routeName = 'Green Line';
                                }
                                color = lineColors['Green Line B'] || '#00843D';
                            }
                        }
                    }
                    
                    // Create train marker with custom line-specific icons
                    let trainIcon;
                    
                    if (routeName.includes('Red Line') || routeName.includes('Mattapan')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/readlinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Blue Line')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/bluelinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Green Line') || routeName.includes('Green-')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/greenlinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else if (routeName.includes('Orange Line')) {
                        trainIcon = L.icon({
                            iconUrl: 'icons/orangelinecirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    } else {
                        // Use commuter rail icon for all other routes (CapeFlyer, Fairmount, etc.)
                        trainIcon = L.icon({
                            iconUrl: 'icons/commuterrailcirc.png',
                            iconSize: [24, 24],
                            iconAnchor: [12, 12]
                        });
                    }
                    
                    const trainMarker = L.marker([lat, lng], {
                        icon: trainIcon,
                        zIndexOffset: 1000
                    });
                    
                    // Get direction information (inbound/outbound)
                    const direction = train.attributes.direction_id === 0 ? 'Inbound' : 'Outbound';
                    
                    // Create popup with train info
                    let popupContent = `
                        <div style="color: ${color}; font-weight: bold;">
                            <img src="${trainIcon.options.iconUrl}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 8px;">
                            Live Train
                        </div>
                        <b>Route:</b> ${routeName}<br>`;
                    
                    // Only show speed if it's a valid number
                    if (speed !== null && speed !== undefined && speed !== 'none' && !isNaN(speed) && speed > 0) {
                        popupContent += `<b>Speed:</b> ${Math.round(speed * 2.237)} mph<br>`;
                    }
                    
                    // Add current status if available
                    if (currentStatus) {
                        let statusText = currentStatus;
                        if (currentStatus === 'STOPPED_AT') {
                            statusText = 'Stopped';
                        } else if (currentStatus === 'IN_TRANSIT_TO') {
                            statusText = 'In Transit';
                        } else if (currentStatus === 'INCOMING_AT') {
                            statusText = 'Incoming';
                        }
                        popupContent += `<b>Status:</b> ${statusText}<br>`;
                    }
                    
                    popupContent += `
                        <b>Train ID:</b> ${trainId}<br>`;
                    
                    // Show terminus for specific lines, direction ID for others
                    if (routeName.includes('Red Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Alewife<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Ashmont/Braintree<br>`;
                        }
                    } else if (routeName.includes('Orange Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Oak Grove<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Forest Hills<br>`;
                        }
                    } else if (routeName.includes('Blue Line')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Wonderland<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Bowdoin<br>`;
                        }
                    } else if (routeName.includes('Green Line B')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Government Center<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Boston College<br>`;
                        }
                    } else if (routeName.includes('Green Line C')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Government Center<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Cleveland Circle<br>`;
                        }
                    } else if (routeName.includes('Green Line D')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Union Square<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Riverside<br>`;
                        }
                    } else if (routeName.includes('Green Line E')) {
                        if (train.attributes.direction_id === 1) {
                            popupContent += `<b>Terminus:</b> Medford/Tufts<br>`;
                        } else {
                            popupContent += `<b>Terminus:</b> Heath Street<br>`;
                        }
                    } else {
                        popupContent += `<b>Direction ID:</b> ${train.attributes.direction_id}<br>`;
                    }
                    
                    popupContent += `
                        <b>Position:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                        <b>Last Update:</b> ${new Date().toLocaleTimeString()}
                    `;
                    
                    trainMarker.bindPopup(popupContent);
                    
                    // Store route name with marker for filtering
                    trainMarker.routeName = routeName;
                    
                    // Add to map and store reference
                    trainMarker.addTo(map);
                    trainMarkers.set(trainId, trainMarker);
                }
            });
            

        }
        
        // Start live tracking
        function startLiveTracking() {
            if (trackingInterval) {
                clearInterval(trackingInterval);
            }
            
            // Initial fetch
            fetchLiveTrains();
            
            // Set up interval for updates
            trackingInterval = setInterval(fetchLiveTrains, 30000); // Update every 30 seconds
        }
        

        
        // Stop live tracking
        function stopLiveTracking() {
            if (trackingInterval) {
                clearInterval(trackingInterval);
                trackingInterval = null;
            }
            
            // Clear all train markers
            trainMarkers.forEach((marker, trainId) => {
                if (marker && marker.remove) {
                    marker.remove();
                }
            });
            trainMarkers.clear();
            

        }
        

        

        

        
        // Initially hide seasonal rail since checkbox is unchecked
        seasonalLines.forEach(lineName => {
            if (mbtaStopsData[lineName] && layers[lineName]) {
                map.removeLayer(layers[lineName]);
            }
        });
        
        // Start tracking after a short delay to let the map load
        setTimeout(() => {
            startLiveTracking();
        }, 2000);
        
    </script>
</body>
</html>
